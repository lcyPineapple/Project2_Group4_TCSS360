package GUI;
import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 * The Compass. It will display the relevant wind speed, wind direction,
 * and wind speed units given to it.
 * 
 * @author Benjamin Munoz
 * @version 04-28-2020
 */
public class Compass extends JPanel {
    /**
     * The serial version ID generated by the Eclipse IDE
     */
    private static final long serialVersionUID = 115015697347795151L;
    
    /**
     * The flag determining if this compass should display any data 
     */
    private boolean dataVisible;
    
    /**
     * The flag determining if this compass should display the
     * direction angle.
     */
    private boolean directionAngleVisible;
    
    /**
     * The flag determining if this compass should display the
     * speed.
     */
    private boolean speedVisible;
    
    /**
     * The angle to be displayed on this Compass
     */
    private double displayAngle;
    
    /**
     * The speed to be displayed on this Compass
     */
    private double displaySpeed;
    
    /**
     * The unit of speed to be displayed on this Compass
     */
    private String displaySpeedUnit;
    
    /**
     * Font for the Cardinal Direction
     */
    private Font cardinalFont;
    
    /**
     * Font for the angle
     */
    private Font angleFont;
    
    /**
     * Font for the speed
     */
    private Font speedFont;
    
    /**
     * The array of Cardinal Symbols. Used to assist in the
     * computation of the closest cardinal direction for a given display angle
     */
    private static final String[] CARDINAL_SYMBOLS = {"N", "NE", "E", "SE", "S", "SW", "W", "NW", "N"};
    
    /**
     * The corresponding angles for the Cardinal Symbols. Used to assist 
     * in the computation of the closest cardinal direction for a given
     * display angle 
     */
    private static final int[] CARDINAL_DIRECTIONS = {  0,   45,  90,  135, 180,  225, 270,  315, 360};

    /**
     * The only constructor
     */
    public Compass() {
        super();
        this.displayAngle = 270;
        this.displaySpeed = 0;
        this.displaySpeedUnit = "mph";
        this.dataVisible = true;
        this.speedVisible = true;
        this.directionAngleVisible = false;
    }
    
    
    @Override
    /**
     * Paints this Compass
     * 
     * @param g The graphics context of this Compass
     */
    public void paint(Graphics g) {
        g.setColor(this.getBackground());
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
        g.setColor(Color.BLACK);
        
        // Minimum of the width and height of this panel
        var panelWHMin = Math.min(this.getWidth(), this.getHeight());
        
        // Draw the outer circles
        double cX = this.getWidth() / 2.0;
        double cY = this.getHeight() / 2.0;
        double diameter = 0.95 * panelWHMin;
        
        // location of the upper-left corner of the 
        //    bounding rectangle containing this circle
        double rX = cX - (diameter / 2);
        double rY = cY - (diameter / 2);
        
        g.drawArc((int) Math.round(rX), (int) Math.round(rY),
                  (int) Math.round(diameter), 
                  (int) Math.round(diameter),
                  0, 360);
        
        diameter = 0.89 * Math.min(this.getWidth(), this.getHeight());
        rX = cX - (diameter / 2);
        rY = cY - (diameter / 2);
        g.drawArc((int) Math.round(rX), (int) Math.round(rY),
                (int) Math.round(diameter), 
                (int) Math.round(diameter),
                0, 360);
        
        if (dataVisible) {
         // draw angle line
            // convert from degrees measured clockwise from North
            // to radians measured counter-clockwise from the East
            var drawAngle = 90 - displayAngle;
            drawAngle *= Math.PI / 180;
            
            var dX = Math.cos(drawAngle) * diameter / 2;
            var dY = - Math.sin(drawAngle) * diameter / 2;
     
            g.drawLine((int) Math.round(cX + 0.8 * dX), (int) Math.round(cY + 0.8 * dY), 
                    (int) Math.round(cX + dX), 
                    (int) Math.round(cY + dY));
            
            // draw data text
            cardinalFont = new Font("Monospace", Font.BOLD,
                                    (int) Math.round(130.0 * panelWHMin / 500.0));
            angleFont = new Font("Monospace", Font.BOLD, 
                                 (int) Math.round(30.0 * panelWHMin / 500.0));
            speedFont = new Font("Monospace", Font.BOLD,
                                 (int) Math.round(30.0 * panelWHMin / 500.0));
            
            // determine the heights of the cardinal, angle, and speed strings
            g.setFont(cardinalFont);
            var fontMet = g.getFontMetrics();
            var cardinalFontHeight = fontMet.getMaxAscent() + fontMet.getMaxDescent();
            
            g.setFont(angleFont);
            fontMet = g.getFontMetrics();
            var angleFontHeight = fontMet.getMaxAscent() + fontMet.getMaxDescent();
            
            g.setFont(speedFont);
            fontMet = g.getFontMetrics();
            var speedFontHeight = fontMet.getMaxAscent() + fontMet.getMaxDescent();
            
            // determine the positioning of the cardinal string
            g.setFont(cardinalFont);
            fontMet = g.getFontMetrics();
            var windCardString = "";
            for (int i = 0; i < CARDINAL_DIRECTIONS.length; i++) {
                if (Math.abs(CARDINAL_DIRECTIONS[i] - displayAngle) <= 22.5) {
                    windCardString = windCardString + CARDINAL_SYMBOLS[i];
                }
            }
            var windCardStringWidth = fontMet.stringWidth(windCardString);
            var windCardStringX = (int) Math.round((this.getWidth() - windCardStringWidth) / 2.0);
            var windCardStringY = (int) Math.round((this.getHeight() - (cardinalFontHeight + angleFontHeight + speedFontHeight)) / 2.0);
            windCardStringY += cardinalFontHeight;
            g.drawString(windCardString, windCardStringX, windCardStringY);
            
            if (directionAngleVisible) {
                // determine the positioning of the angle string
                g.setFont(angleFont);
                fontMet = g.getFontMetrics();
                var windDirString = displayAngle + "°";
                var windDirStringWidth = fontMet.stringWidth(windDirString);
                var windDirStringX = (int) Math.round((this.getWidth() - windDirStringWidth) / 2.0);
                var windDirStringY = (int) Math.round((this.getHeight() - (cardinalFontHeight + angleFontHeight + speedFontHeight)) / 2.0);
                windDirStringY += cardinalFontHeight + angleFontHeight;
                
                g.drawString(windDirString, windDirStringX, windDirStringY);
            }

            if (speedVisible) {
                // determine the positioning of the speed string
                g.setFont(speedFont);
                fontMet = g.getFontMetrics();
                var windSpeedString = displaySpeed + " " + displaySpeedUnit;
                var windSpeedStringWidth = fontMet.stringWidth(windSpeedString);
                var windSpeedStringX = (int) Math.round((this.getWidth() - windSpeedStringWidth) / 2.0);
                var windSpeedStringY = (int) Math.round((this.getHeight() - (cardinalFontHeight + angleFontHeight + speedFontHeight)) / 2.0);
                windSpeedStringY += cardinalFontHeight + angleFontHeight + speedFontHeight;
                
                g.drawString(windSpeedString, windSpeedStringX, windSpeedStringY);    
            }
        }
    }
    
    /**
     * Sets the display angle, speed, and speed unit of this compass 
     * 
     * @param angle - the angle measured in degrees clockwise from North
     * @param speed - the speed in units of the speedUnit
     * @param speedUnit - the units of speed
     */
    public void setDisplayData(double angle, double speed, String speedUnit) {
        this.displayAngle = angle % 360;
        if (displayAngle < 0) {
            displayAngle += 360;
        }
        
        // The user manual indicates that north should be indicated 
        //    as 360 degrees.
        if (displayAngle == 0) {
            displayAngle = 360;             
        }
        
        this.displaySpeed = speed;
        this.displaySpeedUnit = speedUnit;
        this.repaint();
    }
    
    /**
     * Sets the visiblity of the data in this compass.
     * 
     * @param flag - determines if the data is visible.
     */
    public void setDataVisible(boolean flag) {
        this.dataVisible = flag;
        this.repaint();
    }
    
    public void toggleSpeedDirection() {
        if (directionAngleVisible) {
            directionAngleVisible = false;
            speedVisible = true;
        } else {
            directionAngleVisible = true;
            speedVisible = false;
        }
    }
    
    /**
     * A main program to demo the Compass
     * 
     * @param args -- Not utilized
     */
    public static void main(String...args) {
        EventQueue.invokeLater(() -> {
            var frame = new JFrame();
            frame.setSize(300, 300);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            
            var cg = new Compass();
            frame.add(cg);
            frame.setVisible(true);
           
            Timer s = new Timer();
            s.scheduleAtFixedRate(new TimerTask() {
                public void run() {
                    var angle = (Math.random() * 360);
                    var speed = (Math.random() * 100);
                    angle = Math.floor(angle * 100) / 100.0;
                    speed = Math.floor(angle * 100) / 100.0;
                    cg.setDisplayData(angle, speed, Math.random() <= 0.5 ? "mph" : "km/h");
                    if (Math.random() <= 0.5) {
                        cg.toggleSpeedDirection();
                    }
                }
            }, 0, 1000);
        });
    }
}
